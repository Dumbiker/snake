<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>8-Bit Snake Game with Enemies & Health</title>
<style>
  body {
    background: #111;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    font-family: monospace;
    user-select: none;
  }
  #game-container {
    position: relative;
  }
  canvas {
    border: 4px solid #555;
    image-rendering: pixelated;
    background: black;
  }
  #ui {
    width: 320px;
    color: white;
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
  }
  #health {
    display: flex;
    gap: 4px;
  }
  .heart {
    width: 20px;
    height: 20px;
    background: red;
    clip-path: polygon(
      50% 0%, 61% 14%, 75% 14%, 88% 27%, 88% 43%,
      75% 56%, 50% 85%, 25% 56%, 12% 43%, 12% 27%,
      25% 14%, 39% 14%
    );
  }
  #score {
    font-size: 1.2rem;
  }
  #start-btn {
    margin-top: 12px;
    background: #222;
    color: white;
    border: 2px solid #555;
    padding: 8px 16px;
    font-size: 1.1rem;
    cursor: pointer;
  }
  #start-btn:hover {
    border-color: limegreen;
    color: limegreen;
  }
</style>
</head>
<body>

<div id="game-container">
  <div id="ui">
    <div id="health"></div>
    <div id="score">Score: 0</div>
  </div>
  <canvas id="game" width="320" height="320"></canvas>
</div>
<button id="start-btn">Start Game</button>

<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const healthContainer = document.getElementById("health");
  const scoreDisplay = document.getElementById("score");
  const startBtn = document.getElementById("start-btn");

  const gridSize = 20;
  const tileCount = canvas.width / gridSize;

  let snake, direction, apple, score, frame, health;
  let enemies = [];
  let enemyRespawnTimes = [];
  let gameRunning = false;

  // Initialize hearts UI
  function updateHealthUI() {
    healthContainer.innerHTML = "";
    for(let i = 0; i < health; i++) {
      const heart = document.createElement("div");
      heart.classList.add("heart");
      healthContainer.appendChild(heart);
    }
  }

  // Random position helper
  function randomPos() {
    return {
      x: Math.floor(Math.random() * tileCount),
      y: Math.floor(Math.random() * tileCount)
    };
  }

  // Place apple avoiding snake and enemies
  function placeApple() {
    let pos;
    do {
      pos = randomPos();
    } while (snake.some(s => s.x === pos.x && s.y === pos.y) || enemies.some(e => e.active && e.x === pos.x && e.y === pos.y));
    apple = pos;
  }

  // Place enemy avoiding snake and apple
  function placeEnemy() {
    let pos;
    do {
      pos = randomPos();
    } while (
      snake.some(s => s.x === pos.x && s.y === pos.y) ||
      (apple.x === pos.x && apple.y === pos.y) ||
      enemies.some(e => e.active && e.x === pos.x && e.y === pos.y)
    );
    return pos;
  }

  function resetGame() {
    snake = [{ x: 10, y: 10 }];
    direction = { x: 0, y: 0 };
    score = 0;
    health = 5;
    frame = 0;
    enemies = [];
    enemyRespawnTimes = [];
    placeApple();
    updateHealthUI();
    updateScore();
  }

  function updateScore() {
    scoreDisplay.textContent = `Score: ${score}`;
  }

  // Start the game
  function startGame() {
    resetGame();
    direction = { x: 1, y: 0 }; // Start moving right immediately
    gameRunning = true;
    startBtn.style.display = "none";
    requestAnimationFrame(gameLoop);
  }

  // Draw functions
  function drawRect(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
  }

  // Game loop
  function gameLoop() {
    if (!gameRunning) return;

    requestAnimationFrame(gameLoop);

    if (++frame % 6 !== 0) return; // Slow down game speed

    // Move snake
    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
    head.x = (head.x + tileCount) % tileCount;
    head.y = (head.y + tileCount) % tileCount;

    // Check collision with self
    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);

    // Check apple collision
    if (head.x === apple.x && head.y === apple.y) {
      score += 10;
      placeApple();

      // Every 10 apples add enemy
      if ((score / 10) % 10 === 0) {
        let enemyPos = placeEnemy();
        enemies.push({ x: enemyPos.x, y: enemyPos.y, active: true });
        enemyRespawnTimes.push(0);
      }
      updateScore();
    } else {
      snake.pop();
    }

    // Handle enemies
    enemies.forEach((enemy, i) => {
      if (enemy.active) {
        // Check collision with snake
        if (snake.some(s => s.x === enemy.x && s.y === enemy.y)) {
          health--;
          updateHealthUI();

          enemy.active = false;
          enemyRespawnTimes[i] = frame + 60 * (10 + Math.floor(Math.random() * 6)); // respawn after 10-15 sec (60fps)
          if (health <= 0) {
            gameOver();
            return;
          }
        }
      } else {
        // Respawn check
        if (frame >= enemyRespawnTimes[i]) {
          let newPos = placeEnemy();
          enemy.x = newPos.x;
          enemy.y = newPos.y;
          enemy.active = true;
        }
      }
    });

    // Draw game board
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw apple
    drawRect(apple.x, apple.y, "red");

    // Draw enemies
    enemies.forEach(enemy => {
      if (enemy.active) {
        drawRect(enemy.x, enemy.y, "deepskyblue");
      }
    });

    // Draw snake
    snake.forEach(segment => {
      drawRect(segment.x, segment.y, "limegreen");
    });
  }

  function gameOver() {
    gameRunning = false;
    alert(`Game Over! Your final score was ${score}`);
    startBtn.style.display = "inline-block";
  }

  // Controls
  document.addEventListener("keydown", e => {
    if (!gameRunning) return;
    switch (e.key) {
      case "ArrowLeft":
        if (direction.x === 0) direction = { x: -1, y: 0 };
        break;
      case "ArrowUp":
        if (direction.y === 0) direction = { x: 0, y: -1 };
        break;
      case "ArrowRight":
        if (direction.x === 0) direction = { x: 1, y: 0 };
        break;
      case "ArrowDown":
        if (direction.y === 0) direction = { x: 0, y: 1 };
        break;
    }
  });

  startBtn.addEventListener("click", startGame);

  updateHealthUI();
</script>

</body>
</html>
